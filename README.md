# Your Location

## Set up
This website was created with [Jekyll](https://jekyllrb.com/docs/). I already have Jekyll site ready, you just need to run it locally.After you fork this repo, do the following to get set up:

1. Install a [Ruby environment](https://jekyllrb.com/docs/installation/) per Jekyll's documentation. 
2. Run `gem install jekyll bundler` in your terminal to install Jekyll
3. Run `bundle` in your to terminal to install all dependencies. 
4. Run `bundle exec jekyll serve --livereload`. See the documentation for [command line usage](https://jekyllrb.com/docs/usage/) if you have any questions. 
5. Check http://localhost:4000 to see if you're in business. 

## How Jekyll Works
Now that you have Jekyll running locally, you'll notice a new directory has appeared: `_site`. This directory is the complete site output that gets generated by Jekyll. You'll notice there's all of the pages, CSS, and JS compiled and ready for the world. This is what you need to host. You'll notice The homepage (`index.html`) is served from the root, but the privacy policy is served from the `privacy-policy` directory. I used [Jekyll's Collections feature](https://jekyllrb.com/docs/collections/) to keep my content organized and adding a custom [permalink](https://jekyllrb.com/docs/permalinks/) means it will be served from a named directory with an `index.html` file. So the path is `/privacy-policy/index.html` but we want the user to access it via `/privacy-policy/`.

Jekyll has [additional documentation](https://jekyllrb.com/docs/deployment/) on deployments if you need further guidance. 


DevOps Assignment:

Our developer just built a website for a client on Jekyll. Everything is QA’d and ready to roll, but it’s not online. Our developers need a staging area to add and test features, and our client wants mylocationhw.com live yesterday.Our trusty developer left detailed instructions on how to get a Jekyll site up and running, but they aren’t sure how to get it on mylocationhw.com. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Shai's Homework - 8/26/20
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Once I confirmed that I could run the Jekyll instance on my local machine, and could view the application in Firefox, I noticed right away that the directory contents and the web app itself was light-weight and would not require huge amounts of data to serve to the user. For this reason I went with a tech stack comprising of Linux (CentOS 8), Apache HTTP Server and Virtual Box. 
 
 ## Downloading Virtual Box to local machine
 *  I am currently running macOS Mojave so I downloaded the appropiate .rpm from Virtual Box's website (https://www.virtualbox.org/wiki/Downloads).
 
 [Virtual Box is fairly easy to use and for abstraction and security purposes I did not want to run Apache from my local machine.]

Once I had Virtual Box installed I decided that my guest OS will be Linux based; as it is highly customizable as a server due to its open source capabilities. From there, I chose the latest CentOS 8 distro from their one of their website mirrors. (http://isoredirect.centos.org/centos/8/isos/x86_64/)

Alternative: AWS EC2 Instance 
For the increased security third-party vendors offer, if the client was interested in some low cost cloud hosts, we could configure our web server through Amazon Web Services and host our server in the cloud. 

## Configuring Virtual Box
The VM once booted with the .iso was configured with the following settings:
Memory - 2048 MB
Storage - 8 GB of Hard Disk Space attached as a Virtual Disk Interface (VDI)
Network - Bridged Adapter - (Should be NAT but this made so I could communicate to my VM from my local machine.)

Before the installation continues you are prompted to select any software/services, select:
Basic Web Server
System Tools
  
In addition, create two users: root (this already is created by default, rather just set a password) and ops-user assinged the role of 'admin'. 

## Configuring the web server
-- For this example, I selected just core CentOS box so all configurations had to be typed cmd line. This was done to save space and access even more configuration options. 

In the terminal enter the following commands as a non-root user w/ elevated privileges: 

$ sudo yum update httpd # Update the local httpd package to reflect any new changes

$ sudo yum install httpd 

Now that you have the Apache Web Service installed, you must open port 80 to allow Apache to serve requests over HTTP/S:

$ sudo firewall-cmd --permanent --add-service=http
$ sudo firewall-cmd --permanent --add-service=https

Reload the firewall for the rules to take effect:

$ sudo firewall-cmd --reload

# Checking your web server

$ sudo systemctl start httpd #manually starts the Apache process

$ sudo systemctl status httpd # verify that it is running

For best practices, if this would be used as a dedicated web server you would need to tell Apache to start on boot. This can be done by

$ sudo systemctl enable httpd 

# Creating Virtual Hosts 
Virtual Hosts are necessary to tell Apache what content to serve for requests. 
Make two directories as follows:

$ sudo mkdir -p /var/www/mylocationhw.com/html
$ sudo mkdir -p /var/www/mylocationhw.com/log 

Assign ownership of the 'html' directory to our current user
$ sudo chown -R $USER:$USER /var/www/mylocationhw.com/html 

Make sure that your web root has default permissions enabled:
$ sudo chmod -R 755 /var/www 

Next create a 'sites-available' and a 'sites-enabled' directory to store our virtual hosts
$ sudo mkdir /etc/httpd/sites-available /etc/httpd/sites-enabled

By default Apache isn't set to look for Virtual Hosts in those directories but by navigating to our httpd.conf file we can tell it to:
$ sudo vim /etc/httpd/conf/httpd.conf

Add this line to the end of the file:
IncludeOptional sites-enabled/*.conf

# Creating Virtual Hosts File 
$ sudo vim /etc/httpd/sites-available/mylocationhw.com.conf

In the file add the following block: 
<VirtualHost *:80>
    ServerName www.mylocationhw.com
    ServerAlias mylocationhw.com
    DocumentRoot /var/www/mylocationhw.com/html
    ErrorLog /var/www/mylocationhw.com/log/error.log
    CustomLog /var/www/mylocationhw.com/log/requests.log combined
</VirtualHost>
 
This will tell Apache where to find the root directly that holds the publicly accessible web documents. 
It also tells Apache where to store error and request logs for this particular site.

# Adding staging subdomain 
<VirtualHost *:80>
ServerName staging.mylocationhw.com
DocumentRoot /var/www/staging.mylocationhw.com/site/_site
</VirtualHost>

(Developers would commit their changes to staging branch which can then be checked out into /var/www/staging.mylocationhw.com to create a staging environment)

  
# Create a symbolic link for each virtual hosts 
$ sudo ln -s /etc/httpd/sites-available/mylocationhw.com.conf /etc/httpd/sites-enabled/mylocationhw.com.conf

# Adjustng SELinux Permissions 
$ sudo setsebool -P httpd_unified 1 # sets a universal Apache policy 

# Editing httpd.conf 
Added the following lines:

DocumentRoot "/var/www/mylocationhw.com/site/_site" [Where Apache should look for the content to server (index.html)]

Under <Directory "/var/www/mylocationhw.com/html/site/_site">

add 
Options Indexes FollowSymlinks 


# Install Jekyll for CentOS
Using the installation instructions above, create a new instance to run on the VM this time.

# Install GIT on the VM
$ sudo dnf update -y #Update the dnf package installer
$ sudo dnf install git -y 

# Bash script to build Jekyll directory and point _site to Document Root
$ sudo vim deploy.sh 

In the file add the following lines:
JEKYLL_ENV=bundle exec jekyll serve --host 0.0.0.0 --livereload 
(I added 0.0.0.0 instead of localhost or loopback because that would limit access to the instance to my VM and I wanted to test in my local browser as well.)

rsync -avr /home/ops-user/git/devops-homework/_site

Once this is ran you can access the site via the web-server's IP Address:4000 and be served contents from the _site directory~ 
Example (https://drive.google.com/file/d/1JowNlyPUwEWpSay5wijSamxOcX4Y_Ma8/view?usp=sharing)

# Adding SSL certs 
$ sudo yum install install mod_ssl.x86_64
Simply restart the server after installing this, and it will include a self signed certificate.

# Created a new self-signed SSL certificate
$ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/certs/mylocationhw.key -out /etc/ssl/certs/mylocationhw.crt 
creates a new certificate and allows you to specify fields like domain, company name, email address, city, state, etc. and saves the certificate and the key in the /etc/ssl/certs directory.

# Re-edit httpd.conf file
<VirtualHost *:80>
    ServerName www.mylocationhw.com
    ServerAlias mylocationhw.com
    DocumentRoot /var/www/mylocationhw.com/html
    SSLEngine on
    SSLCertificateFile /etc/ssl/certs/mylocationhw.crt
    SSLCertificateKeyFile /etc/ssl/certs/romylocationhw.key
    ErrorLog /var/www/mylocationhw.com/log/error.log
    CustomLog /var/www/mylocationhw.com/log/requests.log combined
</VirtualHost>
 
# Domain Name Resolution 
mylocationhw.com isn't live yet because we haven't registered our domain. 

Possible domain registrars include Namecheap and GoDaddy that offer low cost DNS services. 
Once you have your domain available and set aside. Locate the name servers/DNS records of your host. 

# Reverse lookup nameserver 
In any terminal, enter the following:

nslookup nameserver.example.com 
You should be returned with a public ip address. This needs to be added to your /etc/resolv.conf so your machine uses your domain's nameserver to query hosts. 

Your web server also has a public IP address, add an 'A' record in your domain management settings that points to your machine's public IP so that other computers know where to find you. 

** Very important to make sure all the necessary security controls/restrictive access are in place before placing your website on the interwebs! 

To summarize, now when users type mylocationhw.com in their web browser; their router/internet gateway is returned with a response from our Registrar's nameserver. This response lets clients know that mylocationhw.com points to our public IP address and Apache responds to this request by serving content from our Document Root. Underneath the hood of course, the Document Root really points at the '_site' directory and is rsynced whenever we call
bundle exec jekyll serve --host 0.0.0.0 --livereload  

Due to the neat permalinks you've included the privacy policy is served from the /privacy-policy/index.html but accessed through /privacy-policy. 
Example (https://drive.google.com/file/d/1YxFu9Cv5VCfXbwxvehvUUth6-ihCXGCl/view?usp=sharing) 

The client now has a live website that developers can stage features and updates before pushing to production!



  
  
  
  
